# üéØ UVL2Pat

**Universal Design Patterns Generator - From UVL Feature Models to Swift Code**

Transform Universal Variability Language models into Swift design pattern implementations with future multi-language support

---

## üìä Project Stats

| Design Patterns | Primary Language | Pattern Variants | Feature Models |
|:---------------:|:----------------:|:----------------:|:--------------:|
| 7+ | Swift | ‚àû | UVL |

---

## ‚ú® Features

- **Swift Code Generation**: Generate high-quality Swift implementations of design patterns
- **UVL Integration**: Use Universal Variability Language for feature modeling
- **Template-Based Generation**: Flexible Jinja2 templates for Swift code
- **Constraint Validation**: Automatic validation of feature model constraints
- **Pattern Variants**: Generate multiple implementations of the same pattern
- **FlamaPy Integration**: Advanced feature model analysis and operations
- **Future Multi-Language Support**: Architecture designed for Kotlin, Java, Dart, C# expansion

## üåê Supported Languages

| Language | Status | Description |
|----------|--------|-------------|
| üçé **Swift** | ‚úÖ **Available Now** | iOS/macOS Development |
| ü§ñ **Kotlin** | üöß Planned | Android/JVM Development |
| ‚òï **Java** | üöß Planned | Enterprise Development |
| üéØ **Dart** | üöß Planned | Flutter Development |
| ‚ö° **C#** | üöß Planned | .NET Development |
| üöÄ **More** | üîÆ Future | Extensible Architecture |

> **Current Focus:** UVL2Pat currently supports Swift with a robust, extensible architecture designed for future multi-language expansion. The template system and UVL integration provide a solid foundation for adding support for Kotlin, Java, Dart, C#, and other languages.

## üìã Requirements

```bash
pip install jinja2 flamapy-fm pathlib click
```

## üìÅ Project Structure

```
UVL2Pat/
‚îú‚îÄ‚îÄ patterns/
‚îÇ   ‚îú‚îÄ‚îÄ behavioral/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategy/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strategy.uvl
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ strategy.swift.j2
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ configurations/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ strategy.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ observer/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ observer.uvl
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ observer.swift.j2
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ configurations/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ observer.json
‚îÇ   ‚îú‚îÄ‚îÄ creational/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ factory_method/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ factory_method.uvl
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ factory_method.swift.j2
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ configurations/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ singleton/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ singleton.uvl
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ singleton.swift.j2
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ configurations/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ singleton.json
‚îÇ   ‚îî‚îÄ‚îÄ structural/
‚îÇ       ‚îú‚îÄ‚îÄ adapter/
‚îÇ       ‚îú‚îÄ‚îÄ bridge/
‚îÇ       ‚îî‚îÄ‚îÄ decorator/
‚îú‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```

## üõ†Ô∏è Installation

1. **Clone the repository:**
   ```bash
   git clone https://github.com/trran/UVL2Pat.git
   cd UVL2Pat
   ```

2. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

3. **Install UVL2Pat:**
   ```bash
   pip install -e .
   ```

## üéØ Quick Start

1. **Choose your pattern** by modifying the variables in `main.py`:
   ```python
   # Available categories and patterns:
   # behavioral: strategy, observer
   # creational: factory_method, singleton
   # structural: adapter, bridge, decorator

   general_group = "creational"    # Change category
   pattern = "singleton"           # Change pattern
   ```

2. **Run the generator:**
   ```bash
   python main.py
   ```

3. **Find your generated Swift code** in the output directory.

## üìù Available Patterns

### üé≠ Behavioral Patterns
- **Strategy**: Encapsulate algorithms and make them interchangeable
- **Observer**: Define subscription mechanism for object state notifications
- **Command**: Encapsulate requests as objects `Coming Soon`
- **State**: Alter object behavior when internal state changes `Coming Soon`

### üè≠ Creational Patterns
- **Singleton**: Ensure single instance with global access point
- **Factory Method**: Create objects without specifying exact classes
- **Abstract Factory**: Create families of related objects `Coming Soon`
- **Builder**: Construct complex objects step by step `Coming Soon`

### üèóÔ∏è Structural Patterns
- **Adapter**: Make incompatible interfaces work together
- **Bridge**: Separate abstraction from implementation
- **Decorator**: Add behavior to objects dynamically
- **Facade**: Provide simplified interface to complex subsystem `Coming Soon`

## ‚öôÔ∏è Configuration System

### UVL Model

**Singleton Feature Model (singleton.uvl):**
```uvl
features
    "Singleton Pattern" {abstract}
        mandatory
            "Initialization" {abstract}
                alternative
                    "Eager"
                    "Lazy"
            "Access Method" {abstract}
                alternative
                    "getInstance()"
                    "Static Field"
                    "Property"
        optional
            "Thread Safety"
            "Serialization Support"
            String "Class Name"
            String "Namespace"

constraints
    "Eager" => !"Thread Safety"
    "Static Field" => "Eager"
    "Serialization Support" => "Thread Safety"
```

### JSON Configuration

**Configuration (singleton_threadsafe.json):**
```json
{
  "Eager": false,
  "Lazy": true,
  "Initialization": true,
  "Access Method": true,
  "Thread Safety": true,
  "Serialization Support": false,
  "Class Name": "DatabaseManager",
  "Namespace": "com.example.data",
  "getInstance()": true,
  "Static Field": false,
  "Property": false
}
```

### Swift Template

**Swift Template (singleton.swift.j2):**
```swift
{% set class_name = features.get("Class Name", "Singleton") %}
{% if features.get("Namespace") %}// Namespace: {{ features.get("Namespace") }}{% endif %}
import Foundation
{% if features.get("Thread Safety") and features.get("Lazy") %}
import Dispatch
{% endif %}

class {{ class_name }} {
    {% if features.get("Eager") %}
    static let shared = {{ class_name }}()
    {% elif features.get("Lazy") %}
    {% if features.get("Thread Safety") %}
    private static var _instance: {{ class_name }}?
    private static let queue = DispatchQueue(label: "{{ class_name.lower() }}.queue")
    {% else %}
    private static var _instance: {{ class_name }}?
    {% endif %}
    {% endif %}
    
    private init() {
        // Private initializer
    }
}
```

### Generated Swift Code

```swift
// Namespace: com.example.data
import Foundation
import Dispatch

class DatabaseManager {
    private static var _instance: DatabaseManager?
    private static let queue = DispatchQueue(label: "databasemanager.queue")
    
    private init() {
        // Private initializer
    }
    
    static func getInstance() -> DatabaseManager {
        return queue.sync {
            if _instance == nil {
                _instance = DatabaseManager()
            }
            return _instance!
        }
    }
}
```

## üìä Feature Analysis

| Pattern | Swift Support | UVL Model | Configurations | Template Features |
|---------|---------------|-----------|----------------|-------------------|
| **Singleton** | ‚úÖ Complete | ‚úÖ | 8 variants | Thread Safety, Lazy/Eager, Access Methods |
| **Observer** | ‚úÖ Complete | ‚úÖ | 6 variants | Type Safety, Weak References, Combine |
| **Strategy** | ‚úÖ Complete | ‚úÖ | 4 variants | Protocol-based, Generic Implementation |
| **Factory Method** | üöß In Progress | ‚úÖ | 5 variants | Generic Factories, Protocol Conformance |
| **Decorator** | üöß In Progress | ‚úÖ | 3 variants | Protocol Extensions, Composition |

## üö® Constraint Validation

### UVL Constraint Examples:
- `"Eager" => !"Thread Safety"`: Eager initialization excludes thread safety
- `"Static Field" => "Eager"`: Static field access requires eager initialization
- `"Serialization Support" => "Thread Safety"`: Serialization requires thread-safe implementation

> **Validation Process:** UVL2Pat automatically validates configurations against UVL constraints before code generation, ensuring only valid pattern variants are created.

## ü§ù Contributing

### Adding New Patterns (Swift)
1. Create UVL feature model: `patterns/{category}/{pattern}/{pattern}.uvl`
2. Create Swift template: `patterns/{category}/{pattern}/templates/{pattern}.swift.j2`
3. Add configuration examples: `patterns/{category}/{pattern}/configurations/`
4. Write comprehensive tests for Swift implementation
5. Update documentation

### Preparing for Multi-Language Support
1. Design language-agnostic UVL models
2. Create template structure for future languages
3. Implement language detection and routing
4. Design extensible architecture for new language support

### Swift-Specific Contributions
- **iOS Optimizations**: Memory management, lifecycle patterns
- **SwiftUI Integration**: ObservableObject, StateObject patterns
- **Combine Framework**: Publisher/Subscriber implementations
- **Concurrency**: async/await pattern variations

### Development Process:
1. Fork the repository: `https://github.com/trran/UVL2Pat`
2. Create feature branch: `git checkout -b feature/new-pattern`
3. Implement Swift patterns with tests
4. Submit pull request with comprehensive documentation

## üôã‚Äç‚ôÇÔ∏è Support & Community

- **Issues**: Report bugs and request features on [GitHub Issues](https://github.com/trran/UVL2Pat/issues)
- **Discussions**: Join community discussions on [GitHub Discussions](https://github.com/trran/UVL2Pat/discussions)
- **Documentation**: Full documentation at [uvl2pat.readthedocs.io](https://uvl2pat.readthedocs.io)
- **Examples**: More Swift examples in the [examples/](https://github.com/trran/UVL2Pat/tree/main/examples) directory

---

<div align="center">

**üåü Made with ‚ù§Ô∏è for the Software Engineering Research Community üåü**

*Transforming Feature Models into Code, One Pattern at a Time*

</div>
